.define public PIN_AD_BASE     2
.define public PIN_NOE        15
.define public PIN_O0         18
.define public PIN_RNW        19
.define public PIN_SEL_BASE   26
.define public PIN_SELDT      (PIN_SEL_BASE + 0)
.define public PIN_SELAH      (PIN_SEL_BASE + 1)
.define public PIN_SELAL      (PIN_SEL_BASE + 2)

.define        NOTHING        0b111
.define        ADDRESS_LOW    0b011
.define        ADDRESS_HIGH   0b101
.define        DATA           0b110

.define public SYSCLK_MHZ     125

.define        DELAY_NS       150
.define        GLITCH_NS       25
.define        GLITCH_CYCLES   (GLITCH_NS*SYSCLK_MHZ)/1000
.define        DELAY_CYCLES   (((DELAY_NS*SYSCLK_MHZ)/1000) - GLITCH_CYCLES)

.define        cycle_start     0                ; irq flag to indicate the start of a bus cycle
.define        cycle_active    1                ; irq flag to indivate an active bus cycle (nOE low)
.define        cycle_end       2                ; irq flag to indicate the end of a bus cycle

.program deglitch_phi0
.wrap_target
wait_for_clock_high:
    wait 1 gpio PIN_O0 [GLITCH_CYCLES-1]        ; wait for the clock to go high

    jmp  pin wait_for_clock_low                 ; reject high glitches < GLITCH_NS in length
    jmp  wait_for_clock_high

wait_for_clock_low:
    wait 0 gpio PIN_O0 [GLITCH_CYCLES-1]        ; wait for the clock to go low

    jmp  pin wait_for_clock_low                 ; reject low glitches < GLITCH_NS in length

    irq  set cycle_start                        ; indicates the start of the bus cycle (after deglitching)
    irq  set cycle_end                          ; indicates the end of the bus cycle (after deglitching)

.wrap


.program sample_noe
.wrap_target
start:
    wait 1 irq cycle_start                      ; wait and clear the cycle_start irq
    set  y DELAY_CYCLES
delay:                                          ; delay to allow nOE to stableize
    jmp  y-- delay
    jmp  pin start                              ; sample nOE and jump back to start if high (not being accessed)
    irq  set cycle_active                       ; trigger the next state machine
    irq  clear cycle_end                        ; clear cycle_end so it can be set at the end of this cycle
.wrap


.program access_ram
.side_set 3 opt
.wrap_target
start:
    wait 1 irq cycle_active  side ADDRESS_LOW   ; wait and clear this cycle_active irq
    jmp  pin handle_read                        ; sample RnW and jump to handle_read if high (a read cycle)
    jmp  start                                  ; back to the start again

handle_read:
    in   pins 8              side ADDRESS_HIGH  ; shift A7..0 into ISR, then select the high address byts
    nop  [1]                                    ; delay to allow address to settle:
    nop  [1]                                    ;     output delay + 74LVC4245 delay + input synch delay)
    nop  [1]                                    ;     1 cycles + ~10ns + 2/3 cycles = 6 cycles
    in   pins 6              side NOTHING       ; shift A13..8 into ISR
    in   x 18                                   ; shift fixed part of ARM address (held in x) into ISR
                                                ; 32-bits accumulated, so auto-push will happen
                                                ; DMA latency expected to be O(10) cycles
    pull block                                  ; pull 8 bits of data from DMA process into the OSR
    out  pins 8                                 ; output the 8 bits of data
    mov  osr ~NULL                              ; OSR=FFFFFFFF
    out  pindirs 8           side DATA          ; start driving the data bus
    mov  osr NULL                               ; OSR=00000000
    wait 1 irq cycle_end                        ; wait and clear the cycle_end irq
    out  pindirs 8           side NOTHING       ; stop driving the data bus
.wrap

% c-sdk {

    void deglitch_phi0_program_init(PIO pio, uint sm, uint offset) {
        pio_sm_config c = deglitch_phi0_program_get_default_config(offset);
        sm_config_set_jmp_pin (&c, PIN_O0);
        pio_sm_init(pio, sm, offset, &c);
        }


void sample_noe_program_init(PIO pio, uint sm, uint offset) {
        pio_sm_config c = sample_noe_program_get_default_config(offset);
        sm_config_set_jmp_pin (&c, PIN_NOE);
        pio_sm_init(pio, sm, offset, &c);
        }

    void access_ram_program_init(PIO pio, uint sm, uint offset) {
        pio_sm_config c = access_ram_program_get_default_config(offset);
        sm_config_set_jmp_pin (&c, PIN_RNW);
        sm_config_set_in_pins(&c, PIN_AD_BASE);
        sm_config_set_out_pins(&c, PIN_AD_BASE, 8);
        sm_config_set_sideset(&c, 4, true, false);
        sm_config_set_sideset_pins(&c, PIN_SEL_BASE);
        sm_config_set_in_shift(&c, true, true, 32);  // shift right=true, auto-push=true
        sm_config_set_out_shift(&c, true, false, 8); // shift right=true, auto-pull=false
        pio_sm_set_consecutive_pindirs(pio, sm, PIN_SEL_BASE, 3, true);
        pio_sm_init(pio, sm, offset, &c);
        }

%}
