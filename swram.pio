.define public PIN_AD_BASE     2
.define public PIN_NOE        15
.define public PIN_O0         18
.define public PIN_RNW        19
.define public PIN_O0_CLEAN   20

;; The 74LVC4245 level shifter needs a DIR that !RnW, so to save adding a chip use the Pico
;; (this won't be needed on Roland's PCB as he's using 74LVC245)
;; Note: Using GPIO 21 for PIN_RNW_INV didn't work, something else be disabling it!
.define public PIN_RNW_INV    22

.define public PIN_SEL_BASE   26
.define public PIN_SELDT      (PIN_SEL_BASE + 0)
.define public PIN_SELAH      (PIN_SEL_BASE + 1)
.define public PIN_SELAL      (PIN_SEL_BASE + 2)

.define        NOTHING        0b111
.define        ADDRESS_LOW    0b011
.define        ADDRESS_HIGH   0b101
.define        DATA           0b110

.define public SYSCLK_MHZ     150

.define        DELAY_NS       150
.define        GLITCH_NS       25
.define        GLITCH_CYCLES   (GLITCH_NS*SYSCLK_MHZ)/1000
.define        DELAY_CYCLES   (((DELAY_NS*SYSCLK_MHZ)/1000) - GLITCH_CYCLES - 6)

;; PIN_CLOCK is the clock used by the access_ram state machines.
;;
;; Use one of the following:
;;   PIN_O0       to use the original Phi0 clock
;;   PIN_O0_CLEAN to use the deglictched Phi clock (delayed ~50ns)

.define        PIN_CLOCK       PIN_O0_CLEAN

;;
;; DEGLITCH STATE MACHINE
;;
;; This will go away when we have PCB based construction
;;
;; Improvements: Using side select could save two instructions and one cycle latency

.program deglitch_phi0                                  ; 7 instructions
.wrap_target

wait_for_clock_high:
    wait 1 gpio PIN_O0 [GLITCH_CYCLES-1]                ; wait for the clock to go high
    jmp  pin clock_high                                 ; reject high glitches < GLITCH_NS in length
    jmp  wait_for_clock_high
clock_high:
    set  pins 1                                         ; take the cleaned up clock high

wait_for_clock_low:
    wait 0 gpio PIN_O0 [GLITCH_CYCLES-1]                ; wait for the clock to go low
    jmp  pin wait_for_clock_low                         ; reject low glitches < GLITCH_NS in length
clock_low:
    set  pins 0                                         ; take the cleaned up clock low

.wrap


;;
;; INVERT RNW STATE MACHINE
;;
;; This will go away when we have PCB based construction
;;
;; The DIR input of the data bus buffer on the Pico AtomVGA board needs to be driven from !RnW for writes to work

.program invert_rnw                                    ; 1 instruction
.wrap_target
    mov  pins, ~pins                                   ; PIN_RNW_INV = !PIN_RNW
.wrap


;;
;; ACCESS RAM DEGLITCH STATE MACHINE
;;
;; There are two instances of this, one for reads, the other for write, with different wrap targets.
;;
;; Both instances are driving side select every cycle, in theory in exact lock-step. If there
;; were conflicts, I believe the higher number state machine should win, which is the read state machine.
;;

.program access_ram                                     ; 28 instructions
.side_set 3

public read_wrap_target:
    jmp  pin read_data                side DATA         ; sample Rnw and only do the FIFO push/pull on read cycles (RnW=1)
    jmp  idle_data                    side DATA         ; RnW=0, so back to idle
read_data:
    in   x 18                         side DATA         ; shift fixed part of ARM address (held in x) into ISR
    push                              side DATA         ; push the ARM address to the Rx FIFO
    pull block                        side DATA         ; pull the data from the Tx FIFO into the OSR
    out  pins 8                       side DATA         ; output 8 bits of data
    mov  osr ~NULL                    side DATA         ; OSR=FFFFFFFF
    out  pindirs 8                    side DATA         ; start driving the data bus

idle_data:
    wait 0 gpio PIN_CLOCK             side DATA         ; wait for the start of the next cycle with data buffers ENABLED
    set  pindirs 0                    side NOTHING      ; stop driving the data bus
    jmp  delay [1]                    side NOTHING      ; jump to the noe delay code

public entry_point:                                     ; *** Default Entry Point ***

idle:
    wait 0 gpio PIN_CLOCK [3]         side NOTHING      ; wait for the start of the next cycle with data buffers DISABLED

public write_wrap_target:
delay:
    set  y DELAY_CYCLES               side NOTHING      ; should be reached 4 instructions after cycle start IN ALL CASES
loop:
    jmp  y-- loop                     side ADDRESS_LOW  ; delay to allow nOE to stablize

    in   pins (PIN_NOE+1-PIN_AD_BASE) side ADDRESS_LOW  ; nOE in bit 31 of ISR, other bits unknown
    in   null 31                      side ADDRESS_LOW  ; nOE now in bit  0 of ISR, other bits cleared
    mov  y isr                        side ADDRESS_LOW  ; y = nOE (0 or 1)
    jmp  y-- idle                     side ADDRESS_LOW  ; if nOE is high, then loop back to idle

    in   pins 8 [3]                   side ADDRESS_HIGH ; shift A7..0 into ISR, then select the high address byts
    nop  [3]                          side ADDRESS_HIGH ; == 1 cycles + ~10ns + 2/3 cycles = 6 cycles
    in   pins 6                       side ADDRESS_HIGH ; shift A14..8 into ISR

public read_wrap:                                       ; *** READ state machine wraps to read_wrap_target ***

    jmp  pin idle_data                side DATA         ; sample RnW and skip the FIFO push on read cycles (RnW=1)
    in   x 18                         side DATA         ; shift fixed part of ARM address (held in x) into ISR
    push noblock                      side DATA         ; push the 32-bit ARM address
    wait 0 gpio PIN_CLOCK             side DATA         ; wait for the start of the next cycle with data buffers enabled
    in   pins 8                       side NOTHING      ; sample read data
    in   null 24                      side NOTHING      ; pad to 32-bit to allign in LSB
    push noblock                      side NOTHING      ; push the 32-bit ARM data

public write_wrap:                                      ; *** WRITE state machine wraps to write_wrap_target ***


% c-sdk {

    void deglitch_phi0_program_init(PIO pio, uint sm, uint offset) {
        pio_gpio_init(pio, PIN_O0_CLEAN);
        pio_sm_set_consecutive_pindirs(pio, sm, PIN_O0_CLEAN, 1, true);
        pio_sm_config c = deglitch_phi0_program_get_default_config(offset);
        sm_config_set_set_pins(&c, PIN_O0_CLEAN, 1);
        sm_config_set_jmp_pin (&c, PIN_O0);
        pio_sm_init(pio, sm, offset, &c);
        }


    void invert_rnw_program_init(PIO pio, uint sm, uint offset) {
        pio_gpio_init(pio, PIN_RNW_INV);
        pio_sm_set_consecutive_pindirs(pio, sm, PIN_RNW_INV, 1, true);
        pio_sm_config c = invert_rnw_program_get_default_config(offset);
        sm_config_set_in_pins(&c, PIN_RNW);
        sm_config_set_out_pins(&c, PIN_RNW_INV, 1);
        pio_sm_init(pio, sm, offset, &c);
        }

    void access_ram_program_init(PIO pio, uint sm, uint offset, int write_smc) {
        pio_sm_config c = access_ram_program_get_default_config(offset);
        sm_config_set_jmp_pin (&c, PIN_RNW);
        sm_config_set_in_pins(&c, PIN_AD_BASE);
        sm_config_set_out_pins(&c, PIN_AD_BASE, 8);
        sm_config_set_sideset_pins(&c, PIN_SEL_BASE);
        sm_config_set_in_shift(&c, true, false, 32);  // shift right=true, auto-push=false
        sm_config_set_out_shift(&c, true, false, 8);  // shift right=true, auto-pull=false
        pio_sm_set_consecutive_pindirs(pio, sm, PIN_SEL_BASE, 3, true);
        if (write_smc) {
            sm_config_set_wrap(&c, offset + access_ram_offset_write_wrap_target, offset + access_ram_offset_write_wrap - 1);
        } else {
            sm_config_set_wrap(&c, offset + access_ram_offset_read_wrap_target,  offset + access_ram_offset_read_wrap  - 1);
        }
        pio_sm_init(pio, sm, offset + access_ram_offset_entry_point, &c);
        }
%}
